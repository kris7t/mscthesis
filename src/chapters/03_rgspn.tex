\chapter{Modular formalism for stochastic~models}
\label{chap:rgspn}

In our current work we aim to propose an approach for the construction of stochastic models from engineering models without human intervention in order to evaluate automatically derived architecture proposals in design-space exploration by stochastic analysis.

The proposed transformation process should be flexible in the sense that---instead of basing our approach on a single engineering modeling language such as \textabbr{UML}~\citep{Rumbaugh04uml}, Sys\mixedabbr{ML}~\citep{Friedenthal16sysml}, \textabbr{AADL}~\citep{Feiler12aadl} or Palladio~\citep{Becker08palladio}---the creation of transformations for new architectural domain-specific languages (\textAbbr{DSL}s) in new problem domains should be supported and should not demand additional specialized knowledge from the users. Therefore the formal models should be based on a stochastic formalism that has sufficient descriptive power to support engineering practice. In addition, compatibility of the derived models with existing stochastic verification tools should be ensured so that recent developments in formal methods may be leveraged for high-performance analysis. Hence reusing an existing formalism is dictated by both \circled{1}~ease of use and \circled{2}~portability.

Analysis tools separate the input formal model and the \emph{query} to be answered \todo*{cite}, which is usually a performance metric to be calculated or a logical requirement to be verified. Therefore, when stochastic models are automatically derived for design-space exploration, \circled{3}~the appropriate queries must also be generated. The queries, which may depend on the structure of the engineering model in the same way as the derived stochastic model, serve as the objective functions and constraints of the exploration strategy.

To achieve these three objectives, in this chapter we turn to stochastic modeling approaches with modules to propose a formalism for the \emph{modules} (or \emph{fragments}) of the stochastic model corresponding to the analyzed aspects of the engineering model. The transformation, which is discussed in \cref{chap:transform}, will instantiate the modules specified by the user to automatically derive the analysis model.

After briefly reviewing related work, we describe our proposed formalism based on modular Petri nets, an extension of the \textabbr{ISO}/\textabbr{IEC}~15909-1:\citeyear{ISO1590912004} standard on High-level Petri nets with a formally defined module concept~\citep{Kindler09modular}.

Petri nets and their extension to stochastic modeling, generalized stochastic Petri nets (\textAbbr{GSPN}s) are a widely used formalism for the analysis of software and hardware systems~\citep{Murata89petri}. Various tools support \textAbbr{GSPN}s, such as \textabbr{SPNP}~\citep{Hirel00spnp}, \textabbr{SMART}~\citep{Ciardo06smart}, M\"obius~\citep{Courtney09mobius}, Great\mixedabbr{SPN}~\citep{Babar10greatspn} and Petri\-Dot\-Net~\citep{Voros17pdn}. Hence we believe most of the target audience of our transformation design-space exploration approach are familiar with them. In addition, to aid finding bugs in the analysis models and to contribute to the \circled{1}~ease of use, static typing, which was first proposed for modular high-level Petri nets by \citet{Kindler07modular}, is supported for both the stochastic model and queries.

Models are serialized in the \textabbr{ISO}/\textabbr{IEC}~15909-2:\citeyear{ISO1590922011} \textabbr{PNML} format for \circled{2}~compatibility with a wide variety of external tools.

In order to \circled{3} generate queries for the stochastic models, we follow \citet{Kindler01modular} and extend modular Petri nets with symbols corresponding to the stochastic properties of interest to encode the queries simultaneously with the structure of the analysis model.

\section{Related work: modular stochastic modeling}

In this section we briefly review some existing approaches for modular construction of logical and stochastic formal models, as well as for the specification of properties and metrics of interest over such models. For an overview on performance evaluation techniques for particular component-based software engineering languages, contrasting with our present work that aims to be generic in the engineering \textabbr{DSL}, we direct the interested reader to the survey by~\citet{Koziolek10review}.

We are especially interested in \emph{modular} formalisms that allow assembling structured models from modules (or fragments). While arbitrary combination of modules leads to high expressivity, it also restricts the opportunities for \emph{compositional} verification. On the other hand, a formalism is compositional if the properties of model can be verified recursively by verifying simpler properties of its constituent components. These models are often constructed using \emph{composition operators} that restrict arbitrary modularity in order to enforce property preservation. \todo{Cite!---V{\"o}ri said he has a good reference about this disctinction.}

We opt for modularity instead of compositionality to avoid restricting the model transformations that will automatically assemble the stochastic models according to an architectural \textabbr{DSL} instance. However, this means solution techniques will have to consider the assembled model in its entierty and cannot depend on preservation of the properties of the components.

\subsection{Modeling formalisms}

Continuous-time Markov chains (\textAbbr{CTMC}s) are common tools for the reliability and performability prediction of critical systems~(see e.g.~\cite{Reibman89markov}). However, instead of modeling with \textAbbr{CTMC}s directly, usually higher-level formalisms are used to obtain more compact models. The semantics of these models are defined in terms of \textAbbr{CTMC}s or related stochastic processes, such as Markov regenerative processes~\citep{Logothetis95mrm,Telek96mrm}. Usually the higher-level formalism belongs to one of these three classes:

\newpara \textbf{Queuing networks} (\textAbbr{QN}s) describe the routing of \emph{customers} or \emph{work items} between \emph{queues}. The times spent in queues are described by random variables. \todo{Should we cite a review about \textAbbr{QN}s?}

\newpara \textbf{Stochastic Petri nets} (\textAbbr{SPN}s) are Petri nets where transitions are equiped with expontentially distributed \emph{firing delays}. Generalized stochastic Petri nets (\textAbbr{GSPN}s), may contain transitions with either exponentially distributed delays and \emph{immediate} firing~\citep{Marsan84gspn}. Moreover, deterministic~\citep{Logothetis95mrm} and phase-type distributed~\citep{Longo13phasetype} delays may also be incorporated; however, this makes verification significantly more complicated. Another generalization is the stochastic activity network formalism, where arbitrary input and output gates are allowed~\citep{Sanders01san}.

\newpara \textbf{Stochastic process algebras} incorporate random timings into the denotational semantics of process calculi~\citep{Hermanns02algebra} while allowing compositional verification. However, composition is syntactically restricted to set of allowed process operators, such as parallel and sequential composition of two subprocesses. An example formalism of this class is the Performance Enhanced Process Algebra (\textabbr{PEPA}) defined by \citet{Hillston95pepa}.

\newpara Although all \textAbbr{CTMC}s can be expressed with any of these formalism classes, a significant advantage of higher-level models is the ability to expresses complicated behaviors of systems with small models. In this regard, \textAbbr{GSPN}s can express \textAbbr{QN}s without increasing model size~\citep{Vernon86comparison}. Comparison of Petri nets and process algebras is more difficult due to the vastly differing modeling styles~\citep{Donatelli95comparison}. The definable composition operators for Petri nets only conserve a limited set of properties; for a review we refer to Chapter~2 of the book by \citet{Hejiao12pppnpa}.

\todo*{Write about actual modular formalisms}

\subsection{Query specifications}

\todo*{Review modular query specification languages}

\section{Generalized stochastic Petri net modules}

In this section we propose the specification of modules for \textabbr{GSPN}s simultaneously with their reward measures and queries. When doing so, contradictions may arise in assembling the stochastic model from modules concerning the initial markings of places, the timings to transition firings and the definitions of the queries. In addition, care must be taken to avoid \emph{circularity} in the merged models and queries, i.e.~the structure of the model must not depend on the answers to the queries, as the state space and the \textabbr{CTMC} derived from the model is used in producing the answer. Hence circular dependence between the model and queries makes analysis impossible.

To address these challenges, we base our approach on modular Petri nets~\citep{Kindler01modular}, which define modules as a collection of \emph{symbols} (also referred to as \emph{nodes}) and the \emph{arcs} between them. Petri net places and transitions are represented as symbols. A symbol may either be \emph{concrete} symbol or a \emph{reference} to another symbol. \emph{Imports} of a module are references that are pointed to \emph{exports} of ther modules when the module is instantiated.

A module may only specify additional information about a concrete symbol, such as the initial marking of a concrete place or the rate of a timed transition. Thus there is a master-slave relationship between concrete and reference symbols, which avoids contradictions in assembled models. The specification of measures and queries is restricted analogously.

We incorporate three new symbol \emph{kinds} into modular Petri nets to construct modular \textabbr{GSPN}s. In addition, an \emph{expression language} is proposed to specify the values of both the stochastic attributes of the model elements, such as transition firing rates, and the performance measures and queries of interest. Circularity in models is avoided by an adapting strict typing to mark invalid dependencies as type errors. This approach was inspired by the work of~\citet{Kindler07modular} on strictly typed colored Petri net modules. We call the resulting formalism with extended symbols, expressions and typing \emph{reference generalized stochastic Petri nets} (\textabbr{RGSPN}).

To simplify presentation the separation of module interfaces and implementations, which enable information hiding for the design of modules, will be not considered. Moreover, the assembly of modules into a complete stochastic model is deferred to \cref{chap:transform}. The remainder of this chapter will focus on the structure and semantics of single \textabbr{RGSPN} modules and the \emph{inlining} of \textAbbr{RGSPN}s into \textAbbr{GSPN}s without references, which can be analyzed with existing tools. 

\subsection{Symbols and edges}

The \textabbr{RGSPN} formalism consists of symbols, and \emph{edges} between the symbols. The latter generalize Petri net arcs by also permitting reference assignments and collection memberships among the edges of the Petri net graph.

Each symbol has a \emph{kind}\todo{We should find a better term than \emph{kind}, as in the current implementation, this term is used in another (slightly related) sense for determining the appearance of symbols in textual and graphical concrete syntaxes.},  which determines what information is needed to define the symbol, and a \emph{type}, which determines the context where the symbol may be used. The type system, which is elaborated in \vref{ssec:rgspn:typesystem}, contains type for places, transitions, and variables. However, the mapping between symbol kinds and types is not one-to-one, since the type of references can be set to determine the types of symbols they may point at.

\subsubsection{Symbol kinds}

The \textabbr{RGSPN} formalism has six symbol kinds:

\newpara\textbf{Places} correspond to Petri net places. The token game of the net changes the markings of the places starting from their defined initial marking. The marking is a non-negative whole number, i.e.~colored variants of \textAbbr{GSPN}s are not currently supported. When \textAbbr{RGSPN}s are shown as graphs places are displayed as circles.

\newpara \textbf{Transitions} correspond to Petri net transitions. They are equipped with a \emph{firing policy}, which is either \emph{timed} or \emph{immediate}. Timed transitions have a \emph{rate} parameter, which is the rate of the exponentially distributed firing delay. Immediate transitions have a probability \emph{weight} and a \emph{priority} consistently with the net-level specification of immediate transitions in \textAbbr{GSPN}s~\citep{Teruel03netlevel}. Graphically, timed transitions are rectangles, while immediate transitions are filled.

\newpara \textbf{Variables} are expressions that may refer to the markings of transitions, other variables and parameters of the net. The \emph{type} of the expression determines the context where a reference to a variable may appear in the net. Variables are shown as triangles.

\newpara \textbf{Parameters} are associated with constant real values and express the dependence of the model on continuous parameters. Parameter nodes are preserved during the inlining of the net into a \textabbr{GSPN} as symbolic placeholders. Hence external tools may construct a parametric \textabbr{CTMC} and apply sensitivity analysis~\citep{Blake88sensitivity} parametric solution~\citep{Hahn11parametric,Voros17pdn} or parameter synthesis~\citep{Quatmann16mdp}. The graphical notation for a parameter symbol is a filled triangle.

\newpara \textbf{References} can stand for other symbols from foreign \textabbr{RSGPN} fragments. A reference has a \emph{reference type}, which is the type of the symbol at which it may be \emph{assigned} to point. A reference may only point at a single symbol at a time; however, references may be chain, as long as some concrete symbol can be resolved at the end of the chain. Graphical representation of references is derived from the pointed symbols but uses dashed lines.

References allow assembling different Petri net modules by merely adding reference assignments. As it will be shown in \vref{sec:rgspn:inlining}, setting a single reference can correspond to redirecting many arcs in the net. Hence references help exploiting the modularity already present in the graph structure of Petri nets.

\newpara \textbf{Collections,} similarly to references, point to other symbols. A collection may point to multiple symbols at one is their type is consistent with the \emph{member type} of the collection. The graphical notation is derived from the member type by adding a drop shadow.

Collections enable modular query specification in \textAbbr{RGSPN}s. While Petri nets are graphs, which can be easily extended by adding new arcs, performance measures are queries and described by algebraic expressions of a much stricter tree structure. Although variable references can serve as \enquote{holes} in the expression trees, they do not allow arbitrary aggregation of queries. For example, consider a performance measure which is defined as the sum of other measure corresponding to the components of the system. An expression of the form \(v_1 + v_2\) can only serve as the aggregate measure of exactly two components, which must have their elementary performance measures assigned to the references \(v_1\) and \(v_2\).

In \vref{sec:rgspn:expression} we introduce \emph{aggregation functions} into the syntax of query expressions. This lets the aggregate performance measure be written as \texttt{sum(\(c\))} analogously to the big operator expression \(\sum_{v \in c} v\), where \(c\) is the collection of the constituent elementary measures. Collections may contain duplicate elements so that expressions like \(v + v + v\) can be written in big operator form.

\subsubsection{Edges}

Any relation between two \textabbr{RGSPN} symbol will be called an \emph{edge}. Three kinds\todo{Kind?} of edges are introduced, which are \emph{arcs}, \emph{reference assingments} and \emph{collection memberships}.

Petri net arcs between transitions and places may be \emph{output}, \emph{input} or \emph{inhibitor} arcs. Either end may be a reference to an appropriate place or transition instead of a concrete symbol. Arcs are equipped with possibly marking-dependent \emph{inscription}, which is the number of tokens moved by the transition. If the inscription is the constant \(1\), we will omit it. Parallel arcs between the same symbols and with the same arc kind are forbidden.

Reference assignments connect references to the symbol at which they point. Indirect references, i.e.~\(r_1 \assign r_2\), \(r_2 \assign s\) are possible and arbitrary chains of references may be built. In particular, an \textabbr{RGSPN} may even contain reference cycles (\(r_1 \assign r_2\), \(r_2 \assign r_1\)), or multiple, contradictory assignments (\(r \assign s_1\), \(r \assign s_2\), \(s_1 \ne s_2\)). However, \emph{inconsistent} \textAbbr{RGSPN}s cannot be transformed into \textAbbr{GSPN}s for analysis. Inconsistency handling is discussed in detail in \vref{ssec:rgspn:inconsistent}.

Collection memberships connect collections to their member symbols. Either end of the membership edge may be a reference to a collection or an appropriate member symbol, respectively. In contrast with arcs, parallel membership edges are possible in order to express positive integer-weighted aggregations.

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/rgspn_example}
  \caption{Example \textabbr{RGSPN} model with an aggregate performance measure.}
  \label{fig:rgspn:example}
\end{figure}

\begin{runningExample}
  \label{ex:rgspn:example}
  \Vref{fig:rgspn:example} shows an \textabbr{RGSPN} model of the dining philosophers problem with two philosophers sitting around a table.

  While the immediate transitions \symb{start\-Eating1} and \symb{start\-Eating2} have constant weights and priorities, the timed transitions all refer to different symbols in their rate expressions. Node the difference between the variables \symb{hungry\-Rate1}, \symb{hungry\-Rate2} and the parameters \symb{eating\-Rate1}, \symb{eating\-Rate2}. Although these variables and symbols are all set to real number constants, the parameters are preserved as continuously changeable quantities when the model is passed to an external tool.

  The self-contained subnets \symb{philosohper1} and \symb{philosopher2} contain reference places \symb{right\-Fork1} and \symb{right\-Fork2}. The subnets are connected by reference assignments. The reference places specify no initial marking at all---not even a zero marking---, because they are slaves of the pointed master symbols \symb{left\-Fork2} and \symb{left\-Fork1}, respectively.

  The performance measures \symb{thinking\-Time1} and \symb{thinking\-Time2} are added to the collection \symb{thinking\-Times}. Thus the aggregate performance measure \symb{total\-Thinking\-Time} can be formed by the aggregation operator \lit{sum}.
\end{runningExample}

\subsection{Type system}
\label{ssec:rgspn:typesystem}

Type systems are tractable syntactic methods for proving the absence of certain unwanted behaviors by classifying terms according to the values they compute~\citep[Chapter~1]{Pierce02tapl}. On the other hand, static type systems for symbols in a modular Petri net were introduced by \citet{Kindler07modular}. In \textAbbr{RGSPN}s, types are used in both senses for classifying expressions, which are terms describing the quantitative aspects of the stochastic model, as well as symbols, which carry structural information.

The main unwanted behavior is the dependence of some expression on contextual information that is not available when the expression is evaluated. For example, the inscription of a Petri net arc should not depend on the state space of the Petri net, as the inscriptions themselves determine the reachable states.

The possible types are described by the following \textabbr{EBNF}-like grammar:
\begin{equation}
  \begin{aligned}
    \ebnfVar{Type} &\ebnfEq \lit{place} \mid \lit{tran} \mid \ebnfVar{VarType} \mid \bagtype{\ebnfVar{Type}} \text, \\
    \ebnfVar{VarType} &\ebnfEq \vartype{\ebnfVar{Dependence}}{\ebnfVar{Pretype}} \text,\\
    \rel{Dependence} &\ebnfEq \lit{const} \mid \lit{param} \mid \lit{marking} \mid \lit{weight} \mid \lit{prop} \mid \lit{path} \text, \\
    \ebnfVar{Pretype} &\ebnfEq \lit{int} \mid \lit{double} \mid \lit{boolean} \text.
  \end{aligned} \label{eq:rgspn:type-ebnf}
\end{equation}

The types \lit{place} and \lit{tran} correspond to places and transitions in the \textabbr{RGSPN} and the references thereof. Types of collections are formed by appending the \emph{collection qualifier} suffix \lit{[]} to the type of the members.

The types of variables deviate from routine. Inspired by conventions from the presentation of substructural type systems (see e.g.~\cite{Walker05substructural}) the types of variables are split into a qualifier and a \emph{pretype}. The pretype part expresses the domain of values, \lit{boolean} for truth values \(\mathbb{B} = \{\lit{true}, \lit{false}\}\), \lit{int} for integers and \lit{double} for real numbers.

The \emph{dependence qualifier} specifies the evaluation context of an expression as follows:
\begin{compactitem}
\item A \lit{const} expression yields a value without further input.
\item A \lit{param} expression refers to the values of continuous model parameters, which are embodied by parameter symbols.
\item A \lit{marking} expression refers to the token counts of places; therefore it yields a different value in different Petri net markings.
\item A \lit{weight} expression is both parameter- and marking-dependent.
\item A \lit{prop} expression is a performance measure or query that can be determined by model checking and stochastic analysis, but may also depend on the initial marking.
\item A \lit{path} expression is a path property defined along a trace of model execution. It may be a complete \textabbr{LTL} query or appear as a path formula in a \(\textabbr{CTL}^*\) \lit{prop} query.
\end{compactitem}

Because symbol kinds are separated from types, the type system can be adapted for many different scenarios while leaving the Petri net structure intact. Some of these possible extension based on existing literature are explored in Remarks~\ref{rem:rgspn:parametric} and \ref{rem:rgspn:colored}.

\begin{remark}\label{rem:rgspn:parametric}
  Some analysis methods only allow specific kinds of parameter-dependence, such as \(C^1\) differentiable expressions~\citep{Blake88sensitivity} or rational functions~\citep{Hahn11parametric}. However, no attempt is make to track different classes of parameter-dependent functions in \lit{param} expressions, because the restrictions on parametric expressions are highly specific to these analysis methods. If such validations is required, either the \textabbr{RGSPN} can be inspected when being exported for analysis, or the type system can be modified for the needs of the particular analysis method.
\end{remark}

\subsubsection{Subtyping}

The type system proposed in \cref{eq:rgspn:type-ebnf} can be overly rigid, because otherwise valid usages of expressions are forbidden, e.g.~a \lit{const} literal is incompatible with a \lit{marking} context. We introduce subtyping to our type system for flexibility by enabling coercions between different dependence contexts and pretypes.

Subtyping is a binary relation \({\subtype} \subseteq \rel{Type} \times \rel{Type}\), where \(\tau \subtype \tau'\) signifies that terms of type \(\tau\) are convertible to type \(\tau\). It is reflexive, i.e.~\(\tau \subtype \tau\) for all \(\tau \in \rel{Type}\).

Subtyping for variable types is the direct product of the partial orders
\begin{equation}
  \mleft(\begin{tikzpicture}[x=1cm,y=0.8cm,inner sep=0pt,thick,baseline=(weight.base)]
    \node (const) at (0, 0) {\strut\lit{const}};
    \node (param) at (-1,1) {\strut\lit{param}};
    \node (marking) at (1,1) {\strut\lit{marking}};
    \node (weight) at (0,2) {\strut\lit{weight}};
    \node (prop) at (0,3) {\strut\lit{prop}};
    \node (path) at (0,4) {\strut\lit{path}};
    \draw (const.north) -- (param.south);
    \draw (const.north) -- (marking.south);
    \draw (param.north) -- (weight.south);
    \draw (marking.north) -- (weight.south);
    \draw (weight) -- (prop);
    \draw (prop) -- (path);
  \end{tikzpicture}\mright) \mkern10mu\times\mkern10mu
  \mleft(\;\begin{tikzpicture}[x=1.5cm,y=1.2cm,inner sep=0pt,thick,baseline=($(int.base)!0.5!(double.base)$)]
    \node (int) at (0, 0) {\strut\lit{int}};
    \node (double) at (0,1) {\strut\lit{double}};
    \node (boolean) at (-1,0) {\strut\lit{boolean}};
    \draw (int) -- (double);
  \end{tikzpicture}\;\mright)
\end{equation}
of the sets \rel{Dependence} and \rel{Pretype}, respectively, where comparable elements are connected with upward paths in the style of e.g.~\citet{Walker05substructural}. For example, \(\vartype{\lit {const}}{\lit{int}} \subtype \vartype{\lit{marking}}{\lit{double}}\), because \(\lit{const} \preceq \lit{marking}\) and \(\lit{int} \preceq \lit{double}\) in the partial orders. The semantics of variable type coercions are discussed in \vref{ssec:rgspn:semantics}.

Collection types are covariant in their member types; therefore \(\tau \subtype \tau'\) if and only if \(\bagtype{\tau} \subtype \bagtype{\tau'}\). Type coercion of collections is performed elementwise.

\begin{remark}\label{rem:rgspn:colored}
  It would be possible to include more elaborate abstract syntax and subtyping rules for types, for example to describe colored Petri nets, where scalar token counts in markings are replaced by multisets over the elements of the \emph{color class} or \emph{sort} corresponding to each place. In the colored setting, instead of a single \lit{place} type, types of places carry a sort parameter. \citet{Kindler07modular} studied modular colored Petri nets with sort and operator symbols. A sort symbol reference is a color class that can be imported into the module from outside and is thus left abstract inside the module. Types of places thus may depend on the sort symbols.

  Modular colored nets may also contain \emph{operator} symbols, which transform members of a color class into another. In our framework, these could be modeled by symbols of type \(\tau \to \sigma\), i.e~operators that transform values of type \(\tau\) into values of type \(\sigma\). Thus the syntax of type is extended with~\(\ebnfVar{Type} \ebnfEq \ldots \mid \ebnfVar{Type} \to \ebnfVar{Type}\). The arising challenges seem to require more elaborate type theoretical machinery, such as typed lambda calculus with subtyping (see e.g. Chapters~15 and~16 of~\cite{Pierce02tapl}).
\end{remark}

\subsection{Formal definition}

In this section we first define \textabbr{RGSPN} signatures as set of symbols of various kinds.\todo{Change \emph{kinds}.} Then the definition of an \textabbr{RGSPN} on a given signature is elaborated, which extends the signature with the properties of the symbols and the edges of the net. This separation allows deferring the details of the \emph{expressions} of a signature to \vref{sec:rgspn:expression} even though expression will serves as the properties of symbols in the definition of \textAbbr{RGSPN}s.

\begin{dfn}
  An \emph{\textabbr{RGSPN} signatrue} is a 12-tuple
  \begin{equation}
    \Sigma = \ltup P, T_T, T_i, V, \Par, R, C, \rel{dep}, \rel{pretype}, \rel{value}, \rel{target}, \rel{member}\rtup \text,
  \end{equation}
  where the sets \(P, T_t, T_i, V, \Par, R, C,\) are disjoint and
  \begin{compactitem}
  \item \(P\) is a set of \emph{places};
  \item \(T_T\) and \(T_i\) are a sets of \emph{timed} and \emph{immediate transitions}, respectively;
  \item \(V\) is a set of \emph{variables};
  \item \(\Par\) is a set of \emph{parameters};
  \item \(R\) is a set of \emph{references};
  \item \(C\) is a set of \emph{collections};
  \item \(\rel{dep}\colon V \to \rel{Dependence}\) is the \emph{variable dependence} function;
  \item \(\rel{pretype}\colon V \to \rel{Pretype}\) is the \emph{variable pretype} function;
  \item \(\rel{value}\colon V \cup \Par \to \Expr_\Sigma \cup \mathbb{R}\) is a function, such that \(\rel{value}(v) \in \Expr_\Sigma\) for all \(v \in V\) and \(\rel{value}(\theta) \in \mathbb{R}\) for all \(\theta \in \Par\);
  \item \(\rel{target}\colon R \to \rel{Type}\) is the \emph{reference target type} function;
  \item \(\rel{member}\colon C \to \rel{Type}\) is the \emph{collection member type} function.
  \end{compactitem}
\end{dfn}

We will abuse notation such that \(\Sigma\) also stands for the set \(P \cup T_t \cup T_i \cup V \cup \Par \cup R \cup C\) of all symbols. Furthermore, \(\Expr_\Sigma\) will denote the set of all algebraic expressions that may mention symbols of \(\Sigma\).

\begin{dfn}
  An \emph{\textabbr{RGSPN}} is a 10-tuple \(N = \ltup \Sigma, m_0, \lambda, w, \pi, {\outarc}, {\inarc}, {\inharc}, {\assign}, {\member} \rtup\), where
  \begin{compactitem}
  \item \(\Sigma = \ltup P, T_T, T_i, V, \Par, R, C, \ldots\rtup\) is an \textabbr{RGSPN} signature;
  \item \(m_0 \colon P \to \Expr_\Sigma\) is the \emph{initial marking} function;
  \item \(\lambda \colon T_T \to \Expr_\Sigma\) is the \emph{timed transition rate} function;
  \item \(w\colon T_i \to \Expr_\Sigma\) is the \emph{immediate transition weight} function;
  \item \(\pi\colon T_i \to \Expr_\Sigma\) is the \emph{immediate transition priority} function;
  \item \({\outarc}, {\inarc}, {\inharc} \subseteq \Sigma \times \Expr_\Sigma \times \Sigma\) are the relations of \emph{output, input} and \emph{inhibitor arcs}, respectively, which are free of parallel arcs, i.e.~\(\ltup p, e_1, t \rtup, \ltup p, e_2, t \rtup \in {\outarc}\) implies \(e_1 = e_2\) and this property holds also for \(\inarc\) and \(\inharc\);
  \item \({\assign} \subseteq R \times \Sigma\) is the relation of \emph{reference assignments};
  \item \({\member} \in \rel{Multiset}(\Sigma \times \Sigma)\) is the multiset relation of \emph{collection memberships}.
  \end{compactitem}
\end{dfn}

Note the separation between timed \(T_T\) and immediate transitions \(T_i\). In \textAbbr{GSPN}s timed and immediate transitions are usually discriminated by setting \(\pi(t) = 0\) for all \(t \in T_T\)~\citep{Marsan84gspn}. However, in our setting the priority \(\pi(t)\) may contain an algebraic expression; therefore determining whether \(\pi(t) = 0\) would require nontrivial computations. By explicitly partitioning the set of transitions \(T = T_T \djcup T_i\) this computation is avoided.
 
All quantitative aspects of the net are described by expressions \(\Expr_\Sigma\) with the exception of the values of the parameters, which must be real numbers.\todo{Should this go somewhere else?} As any computation is forbidden inside parameter values, so that parameter synthesis tool may set new values of the parameters without needing to respect any constraints between parameter values implicit in the value computations. Explicit constraints, such as interval bounds for parameters may be added as an extension of \textAbbr{RGSPN}s; however, they are currently not supported. If multiple values depending on a shared set of parameters are needed, variable symbols with value expressions may be used instead.

Edges of the net are between pairs of arbitrary symbols, e.g.~arcs are not restricted to go from place symbols to transition symbols, because any symbol may be replaces by a reference of compatible type. However, reference assignments must assign the symbol to be pointed at to a reference, as no other symbol kind can act as an assignable.

Although parallel arcs are forbidden, parallel collection membership edges are permitted by making \({\member}\) a multiset relation, i.e.~a \emph{bag} of tuples, such as \(\Lbag \ltup c, s \rtup, \ltup c, s \rtup, \ldots \Rbag\).

We will write \(p \overset{e}{\outarc} t\), \(p \overset{e}{\inarc} t\), \(p \overset{e}{\inharc} t\), \(r \assign s\) and \(c \member s\) for \(\ltup p, e, t \rtup \in {\outarc}\), \(\ltup p, e, t \rtup \in {\inarc}\), \(\ltup p, e, t \rtup \in {\inharc}\), \(\ltup r, s \rtup \in {\assign}\) and \(\ltup c, s \rtup \in {\member}\), respectively.

\subsubsection{Type checking}

Types for the symbols of the net are synthesized by the function \(\rel{type}\colon \Sigma \to \rel{Type}\) defined as
\begin{equation}
  \rel{type}(s) = \left\{\begin{array}{@{}l@{\quad}l@{\qquad}l@{\quad}l@{}}
    \lit{place} \text, & \text{if \(s \in P\),}
    & \lit{tran} \text, & \text{if \(s \in T\),} \\
    \vartype{\rel{dep}(s)}{\rel{pretype}(s)} \text, & \text{if \(s \in V\),}
    & \vartype{\lit{param}}{\lit{double}} \text, & \text{if \(s \in \Par\),} \\
    \rel{target}(s) \text, & \text{if \(s \in R\),}
    & \bagtype{\rel{member}(s)} \text, & \text{if \(s \in C\),}
  \end{array}\right.
\end{equation}
The types of places and transitions match their kinds, while variables have a variable type according to their dependence and pretype. The types of parameters are fixed to \(\vartype{\lit{param}}{\lit{double}}\), as they are continuous and parameter dependent by definition. References always have the type of the symbol they may point at; therefore they may stand for the pointed symbol. Collections append a collection type qualifier to the type of their members.

The \emph{typing relation} \({\_} \vdash {\_} \oftype {\_}\) assigns types to expressions \(e \in \Expr_\Sigma\). We write \(\Sigma \vdash e \oftype \tau\) if \(e\) is of type \(\tau\) in the context of the \textabbr{RGSPN} signature \(\Sigma\). As it will be seen in \vref{sec:rgspn:expression} the typing relation respects subtyping, i.e.
\begin{equation}
  \frac{\Sigma \vdash e \oftype \tau \quad \tau \subtype \tau'}{%
    \Sigma \vdash e \oftype \tau'} \Tag{T-Sub} \,\text.
\end{equation}

In well-typed \textAbbr{RGSPN}s, where expressions and edges respect strong typing to ensure context-appropriate use of symbols and expressions within both the structural part of the net and its queries. Below we propose some typing requirements that make analysis tractable without greatly restricting the modeler.

\todo{Should we split the formal stuff and the discussion?}
\begin{dfn}
  An \textabbr{RGSPN} is well-typed if it has the following properties:
  \begin{compactitem}
  \item For all \(p \in P\) the initial marking is an integer constant, \(\Sigma \vdash m_0(p) \oftype \vartype{\lit{const}}{\lit{int}}\).
  \item For all timed transitions \(t \in T_T\) the transition rate is a possibly marking- and parameter-dependent real number, \(\Sigma \vdash \lambda(t) \oftype \vartype{\lit{weight}}{\lit{double}}\).
  \item For all immediate transitions \(t \in T_i\) the probability weight is a possibly marking- and parameter-dependent real number, \(\Sigma \vdash w(t) \oftype \vartype{\lit{weight}}{\lit{double}}\). The transition priority is typed much more conservatively by requiring an integer constant, such that \(\Sigma \vdash \pi(t) \oftype \vartype{\lit{const}}{\lit{int}}\) holds.
  \item For all variables \(v \in V\) the value expression must match the type of the variable, \(\Sigma \vdash \rel{value}(v) \oftype \rel{type}(v)\).
  \item All arcs \(p \overset{e}{\outarc} t\), \(p \overset{e}{\inarc} t\) or \(p \overset{e}{\inharc} t\) go between places and transitions such that \(\rel{type}(p) \subtype \lit{place}\) and \(\rel{type}(t) \subtype \lit{tran}\) holds. The inscription \(e\) may depend on the marking, \(\Sigma \vdash e \oftype \vartype{\lit{marking}}{\lit{int}}\),
  \item For all \(r \assign s\), \(s\) is a compatible target of \(r\), \(\rel{type}(s) \subtype \rel{target}(r)\).
  \item For all \(c \member s\), \(s\) is a valid member of \(c\), \(\rel{type}(s) \subtype \rel{member}(s)\).
  \end{compactitem}
\end{dfn}

\begin{remark}
  The requirements are based on the assumptions in \textabbr{GSPN} and \textabbr{CTMC} solution algorithms. While the inscriptions of arcs \(e\) are allowed to have dependence \lit{marking}, because marking-dependent arcs may lead to simplifications of stochastic models~\citep{Ciardo93decomposition}. However, as some external tools only support arcs with constant inscriptions, \(\Sigma \vdash e \oftype \vartype{\lit{const}}{\lit{int}}\) may be enforced instead for compatibility.

  Similarly, marking-dependent immediate transition weight can also pose a difficulty in solving the model~\citep{Teruel03netlevel}, which can be averted by requiring \(\Sigma \vdash w(t) \oftype \vartype{\lit{param}}{\lit{double}}\) for all \(t \in T_i\). In contrast, some state-space explorations methods, such as the decision diagram based algorithm proposed by~\citet{Marussy17priorities}, may permit marking-dependent priorities \(\Sigma \vdash \pi(t) \oftype \vartype{\lit{marking}}{\lit{int}}\).
\end{remark}
  
From now on all discussed \textAbbr{RGSPN}s will be assumed to be well-typed.

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/rgspn_example_typed}
  \caption{Example \textabbr{RGSPN} with type annotations.}
  \label{fig:rgspn:example-typed}
\end{figure}

\begin{runningExample}
  \Vref{fig:rgspn:example-typed} shows the model from \vref{ex:rgspn:example} extended with type annotations in blue. Places, transitions and parameters have their expected typed \lit{place}, \lit{tran}, \(\vartype{\lit{param}}{\lit{double}}\). Variables are annotated according to their \rel{dep} and \rel{pretype}, while collections bear the collection qualifier suffix \lit{[]}.

  There are several examples of subtyping in action: the symbols \symb{thinking\-Time1}, \symb{thinking\-Time2}, \symb{eating\-Rate1}, \symb{eating\-Rate2} are used as rates of timed transitions despite their types \(\vartype{\lit{const}}{\lit{double}}\) and \(\vartype{\lit{param}}{\lit{double}}\). The collection \symb{thinking\-Times} of \(\vartype{\lit{prop}}{\lit{double}}\) members contains the symbols \symb{thinking\-Time1} and \symb{thinking\-Time2} of type \(\vartype{\lit{marking}}{\lit{int}}\).
\end{runningExample}

\section{Expressions}
\label{sec:rgspn:expression}

\subsection{Typing}

\subsection{Semantics}
\label{ssec:rgspn:semantics}

\section{Reference inlining}
\label{sec:rgspn:inlining}

\subsection{Handling inconsistent models}
\label{ssec:rgspn:inconsistent}

\section{Implementation notes}

\todo*{material to reuse below this point:}

\subsection{Reference \textabbr{GSPN} signatures}

Following the terminology of \emph{modular \textabbr{PNML}} models introduced by \citet{Kindler01modular}, we define the signatures of reference \textabbr{GSPN} models as a collection of symbols. Therefore, in our setting places and transitions of Petri nets are different kinds of symbols.

\emph{Variables} are introduced as another kind of symbols to describe the quantitative aspects of the model, including both parameter-dependence and marking-dependence. Parameters that bound from outside, e.g.\ specified in an instance of an engineering model, as well as expressions that are interpreted as marking-dependent random variables can be modeled as variable symbols.

The possible types of symbols are described by the following \textabbr{EBNF}-like grammar:
\begin{equation}
  \begin{aligned}
    \ebnfVar{Type} &\ebnfEq \lit{place} \mid \lit{tran} \mid \ebnfVar{VarType} \mid \bagtype{\ebnfVar{VarType}} \text, \\
    \ebnfVar{VarType} &\ebnfEq \ebnfVar{Dependence}\ \ebnfVar{Pretype} \text,\\
    \rel{Dependence} &\ebnfEq \lit{const} \mid \lit{marking} \mid \lit{analysis}\text, \\
    \ebnfVar{Pretype} &\ebnfEq \lit{int} \mid \lit{double} \mid \lit{boolean} \text.
  \end{aligned}
\end{equation}
The types of \emph{variables}, i.e.~the types \ebnfVar{VarType}, are of the form \(\delta\, \rho\), where \(\delta \in \rel{Dependence}\) and \(\rho \in \rel{Pretype}\). The dependence \(\delta\) describes the aspects of the model that determine the value of the variable.

Variables with \(\lit{const}\) dependence (e.g.~\(\lit{const int}\)) are constant values and may only depend on the structure of the model. In contrast, \(\lit{marking}\) variables are marking-dependent quantities that can be only evaluated and runtime. They can serve as marking-dependent arc inscriptions, transition rates or random variables used in stochastic analyses. Lastly, variables with \(\lit{analysis}\) dependence describe the analyses to be performed of the model.

The pretype \(\rho\) describes the runtime representation of the computed value of the variable. With an abuse of notation, we will write \(\NN\), \(\RR\) and \(\BB\) for the sets of possible values of \lit{int}, \lit{double} and \lit{boolean} variables, respectively.

In addition to variable symbols, \emph{bags} of variables are also introduced to aggregate quantitative aspects defined in multiple parts of the model. An example of such aggregation is the total operational expenses random variable in a performability model, which is the sum of the operational expense random variables of the different system components. The operational expense variables of the individual components can be collected into a bag before summation.

Composition of Petri net modules is aided by \emph{reference} symbols. We will call non-reference symbols \emph{concrete}. Instead of being defined in the Petri net itself, such reference symbols can be connected to other symbols by reference assignments. We follow the conventions in modular \textabbr{PNML}s~\citep{Kindler01modular}, such that reference symbols can refer to a single concrete symbol, while conrete symbols can be assigned to multiple references.

Hence the formal definition of reference \textabbr{GSPN} signatures:

\begin{dfn}
  A \emph{reference \textabbr{GSPN} \paren{\textabbr{RGSPN}} signature} is a tuple \(\Sigma = \ltup S^\Sigma, S_r^\Sigma, \rel{type} \rtup\), where:
  \begin{compactitem}
  \item \(S^\Sigma\) is a set of \emph{symbols}.
  \item \(S_r^\Sigma \subseteq S^\Sigma\) is the set of \emph{reference symbols}.
  \item \(\rel{type}\colon S^\Sigma \to \rel{Type}\) is the \emph{symbol typing function}.
  \end{compactitem}
\end{dfn}

The places, transitions, variables and bags of a signature \(\Sigma = \ltup S^\Sigma, S_r^\Sigma, \rel{type} \rtup\) can be defined as
\begin{align}
  P^\Sigma &= \{s \in S^\Sigma : \rel{type}(s) = \lit{place}\}\text,
  &T^\Sigma &= \{s \in S^\Sigma : \rel{type}(s) = \lit{tran}\}\text, \\
  V^\Sigma &= \{s \in S^\Sigma : \rel{type}(s) \in \rel{VarType}\}\text,
  &B^\Sigma &= \{s \in S^\Sigma : \rel{type}(s) \in \bagtype{\rel{VarType}}\}\text,
\end{align}
respectively. Moreover, the set of all concrete symbols is \(S_c^\Sigma = S^\Sigma \setminus S_r^\Sigma\),
therefore the sets of concrete places \(P^\Sigma_c = P^\Sigma \cap S_c^\Sigma\), transitions \(T^\Sigma_c = T^\Sigma \cap S_c^\Sigma\) and variables \(V^\Sigma_c = V^\Sigma \cap S_c^\Sigma\) can be formed. The superscript \(\Sigma\) will be omitted when the signature is apparent from context.

\subsubsection{Subtyping}

\begin{figure}%
  \begin{tabu}{@{}XX@{}}
    {\begin{tabu}{@{}X[c]r@{}}
        \(\alpha \subtype \alpha\), & \Tagstyle{S-Refl} \\
        \(\lit{const} \subtype \lit{marking}\), & \Tagstyle{SD-Marking} \\
        \(\lit{const} \subtype \lit{analysis}\), & \Tagstyle{SD-Analysis} \\
        \(\lit{int} \subtype \lit{double}\), & \Tagstyle{SPt-Double}
      \end{tabu}}
    & {\begin{tabu}{@{}X[c]r@{}}
        \(\dfrac{
          \delta_1 \subtype \delta_2 \quad \rho_1 \subtype \rho_2
        }{
          \delta_1\,\rho_1 \subtype \delta_2\,\rho_2
        }\), & \Tagstyle{S-Var} \\[1.5ex]
        \(\dfrac{
          \tau_1 \subtype \tau_2
        }{
          \bagtype{\tau_1} \subtype \bagtype{\tau_2}
        }\) & \Tagstyle{S-Bag}
      \end{tabu}}
  \end{tabu}
  \caption{Subtyping rules for \textabbr{RGSPN} signatures.}
  \label{fig:rgspn:subtype}
\end{figure}

In order to capture valid and invalid assignments of references, the set of types defined in \cref{eq:rgspn:type-ebnf} is augmented with a subtyping relation to express compatibility between symbols. The \emph{\textabbr{RGSPN} subtyping relation} is the largest binary relation \({\subtype} \subseteq \rel{Type}^2 \cup \rel{Dependence}^2 \cup \rel{Pretype}^2\) which satisfies the subtyping rules shown in \cref{fig:rgspn:subtype}.

The rules \textsc{S-Relf} ensures that subtyping is reflexive over both types, dependences and types. The compatibility of variable types is captured by \textsc{S-Var} to follow both dependence and pretype subtyping, while \textsc{S-Bag} makes bags covariant in their member types. \textsc{SD-Marking} and \textsc{SD-Analysis} allow the introduction of dependences, i.e.~a constant may be used where a marking dependent value is required, albeit it depends on the current marking in a trivial way. \textsc{SPt-Double} lets \lit{int} values be coerced into \lit{double} values; however, there are no coertions for \lit{boolean}.

We remark that it would be possible to include more elaborate abstract syntax and subtyping rules for types, for example to describe colored Petri nets. In colored nets, \emph{color classes} or \emph{sorts} are associated with places and scalar token counts are replaced by multisets over the elements of the color class. \citet{Kindler07modular} studied modular colored Petri nets with sort and operator symbols. A sort symbol reference is a color class that can be imported into the module from outside and is thus left abstract inside the module. Types of places thus may depend on the sort symbols.

In addition, modular colored nets may also contain \emph{operator} symbols, which transform members of a color class into another. In our type theoretical framework, these can be modeled by \(\ebnfVar{Type} \ebnfEq \ldots \mid \ebnfVar{Type} \to \ebnfVar{Type}\), i.e.~symbols of type \(\tau \to \tau'\) are operators that transform values of type \(\tau\) into values of type \(\tau'\). Polyporphic operators may also be considered. The arising challenges could be handled by tools from simply typed lambda calculus and system F with subtyping (see e.g.~\citet[Chapters~15 and~26]{Pierce02tapl}).

\subsubsection{Symbol assignment}

An \emph{assignment} between of a reference symbol \(r \in S_r\) and another symbol \(s \in S\) signifies that any occurrence of \(r\) should be replaced by \(s\). Similarly, \emph{appending} the sybol \(s\) symbol to a bag \(b \in S\) signifies that any aggregation expression that refers to \(b\) should account for the value of \(s\).

\begin{dfn}
  \label{dfn:rgspn:assign}
  The relation \({\assign} \subseteq S_r \times S\) is an \emph{\textabbr{RGSPN} assignment relation} of the signature \(\Sigma = \ltup S, S_r, \rel{type} \rtup\) subject to the following conditions:
  \begin{compactenum}
  \item \(\rel{type}(s) \subtype \rel{type}(r)\) for all \(r \assign s\). \label{it:rgspn:assign:subtype}
  \item If \(r \assign s_1\) and \(r \assign s_2\) then \(s_1 = s_2\), i.e.~the relation \(\assign\) is the graph of a function. \label{it:rgspn:assign:single}
  \item There are no \emph{reference cycles} of symbols, that is, sequences \(r_1, r_2, \ldots, r_k, r_{k + 1} = r_1\), where \(r_i \assign r_{i + 1}\) for all \(i = 1, 2, \ldots, k\). \label{it:rgspn:assign:cycle}
  \end{compactenum}
  If for each \(r \in S_r\) there exists some \(s \in S\) such that \(r \assign s\), we say that \(\assign\) is \emph{fully specified}.
\end{dfn}

Condition~\ref{it:rgspn:assign:subtype} ensures that type of \(s\) is a subtype of the type of \(r\), thus \(s\) can be used anywhere \(r\) would occur. Condition~\ref{it:rgspn:assign:single} forbids multiple assignments to the same reference, while condition~\ref{it:rgspn:assign:cycle} prevents cycles of references, where the recursive substitution of references with their assigned symbols would fail to terminate.

As assignments between references are permitted, the relation \rel{assign} must be traversed recursively to extract the concrete symbols corresponding to reference. The condition for fully specified assignment relations ensures that no reference symbol is encountered during this traversal which does not have an assigned symbol. 
\begin{dfn}
  The \emph{concretization} of symbols according to an \textabbr{RGSPN} assignment relation \({\assign} \subseteq S_r \times S\) of \(\Sigma = \ltup S, S_r, \rel{type} \rtup\) is \(\rel{conc}\colon S \to S_c\), where
  \begin{equation}
    \rel{conc}(s) = \begin{cases}
      s, & \text{if \(s \in S_c\),} \\
      \rel{conc}(s'), & \text{if \(s \in S_r\) and \(s \assign s'\).}
    \end{cases}
  \end{equation}
  This function is well-defined if \(\assign\) is fully specified.
\end{dfn}

While only a single symbol can be assigned to a reference, a bag may have many members that describe quantitative aspects that are to be aggregated from different parts of the model. Thus a bag symbol may have any number of \emph{member symbols}.
\begin{dfn}
  The multiset relation \({\member} \in \rel{Multiset}(B \times S)\) is an \emph{\textabbr{RGSPN} bag membership relation} of the signature \(\Sigma = \ltup S, S_r, \rel{type} \rtup\) if \(\bagtype{\rel{type}(s)} \subtype \rel{type}(b)\) for all \(b \member s\).
\end{dfn}

Note that while the assignment relation \(\assign\) is a set of pairs, \(\member\) is defined as a multiset of pairs. To illustrate the advantages of multiset semantics, consider the signature \(\ltup \{b, s, r\}, \{r\}, \rel{type} \rtup\) in the following example: Let \(b \in S_c\) be a bag symbol of type \(\bagtype{\tau}\), and let \(s \in S_c\) and \(r \in S_r\) be a concrete and reference symbol of type $\tau$, respectively. Moreover, let the assignment relation be \((\assign) = \{\ltup r, s\rtup\}\) while the bag membership relation is \((\member) = \Lbag \ltup b, s\rtup, \ltup b, r\rtup\Rbag\). The concrete symbol \(s\) appears twice in the bag \(b\), once by a direct membership pair in \(\member\) and once indirectly by being assigned to the reference \(r\). When we replace \(r\) by its concretization \(\rel{conc}(r) = s\), the membership relation becomes \((\member)' = \Lbag \ltup b, s\rtup, \ltup b, s\rtup\Rbag\), hence \(s\) still appears twice. Were set semantics used instead, the multiplicity of \(r\) would have been changed from 2 to 1 in the bag \(b\).

Alternatively, assigning two symbols with equal concretizations to the same bag could be forbidden, making the \(\member\) from the example above an incorrect bag membership relation. We followd the more lenient route by multiset semantics, as it yields more predictable behavior when a union \((\member) = (\member)_1 \uplus (\member)_2\) of membership relations is considered.

\begin{dfn}
  The \emph{member symbols} of bag symbols according to an \textabbr{RGSPN} assignment relation \({\assign} \subseteq S_r \times S\) and bag membership relation \({\member} \in \rel{Multiset}(B \times S)\) of \(\Sigma = \ltup S, S_r, \rel{type} \rtup\) is \(\rel{members}\colon B \to \rel{Multiset}(S_c)\), where
  \begin{equation}
    \label{eq:rgspn:member-symbols}
    \rel{members}(b) = \Lbag \rel{conc}(r) : b' \member r, \rel{conc}(b) = \rel{conc}(b')\Rbag \text.
  \end{equation}
  This function is well-defined if \(\assign\) is fully specified and yields the empty multiset for bags with no member symbols.
\end{dfn}

The process of replacing symbols with their concretizations in the membership relation is captured in the member symbols function to find the members of a bag. \Cref{eq:rgspn:member-symbols} uses concretization to handle the cases when either the bag, its member symbols or both are references. The multiplicities of members are preserved because \(\rel{members}\) is multiset-valued.

\subsubsection{Signature composition}

While the proposed assignment and membership relations are interpreted over a single signature \(\Sigma\), it is possible compose modules by \textabbr{RGSPN} assignment. Let the \emph{disjoint union} \(\Sigma = \Sigma_1 \sqcup \Sigma_2\) of \(\Sigma_1 = \ltup S_1, S_{r,1}, \rel{type}_1 \rtup\) and \(\Sigma_2 = \ltup S_2, S_{r,2}, \rel{type}_2 \rtup\) denote the signature \(\Sigma = \ltup S_1 \sqcup S_2, S_{r,1} \sqcup S_{r,2}, \rel{type} \rtup\) with \(\rel{type}\) extended to \(S_1 \sqcup S_2\) in the straightforward way. This operator is commutative, associative and the the \emph{empty signature} \(\Sigma_\emptyset = \ltup \emptyset, \emptyset, \rel{type}_\emptyset\rtup\) is its unit, where \(\rel{type}_\emptyset\) is trivial.

The \emph{composition} of \textabbr{RGSPN} modules with signatures \(\Sigma_1\) and \(\Sigma_2\) can be described by the assigment relation \((\assign) = (\assign)_1 \cup (\assign)_2 \cup (\assign)_{1,2}\) over the signature \(\Sigma_1 \sqcup \Sigma_2\), where \((\assign)_1\) and \((\assign)_2\) are reference assignments in \(\Sigma_1\) and \(\Sigma_2\), respectively, while \((\assign)_{1,2}\) intermixes the symbols of the two source signatures. The membership relation \((\member) = (\member)_1 \uplus (\member)_2 \uplus (\member)_{1,2}\) factors similarly via multiset union. This construction generalizes to the composition of multiple modules by exploiting associativity and commutativity.

\subsection{Expressions}

In this section we propose an abstract syntax for expressions that describe the quantitative aspects of reference \textabbr{GSPN} models. Such expressions will describe the arc inscription, the initial marking a and the firing distributions of the Petri net. In addition, the reward measures to be evaluated will be also written in the same manner.

Given an \textabbr{RGSPN} signature \(\Sigma\) we define \(\rel{Expr}(\Sigma)\) as the set of valid expressions over \(\Sigma\). This set is described with an \textabbr{EBNF}-like notation as follows. Note that we only consider finite expression trees, thus \(\rel{Expr}(\Sigma)\) is a least fixed point described by the following \textabbr{EBNF}-like grammar:
\begin{equation}
  \label{eq:rgspn:expression}
  \begin{aligned}
    \ebnfV{\rel{Expr}(\Sigma)} &\ebnfEq \ebnfVar{Unary}\; \ebnfV{\rel{Expr}(\Sigma)}
    \mid \ebnfV{\rel{Expr}(\Sigma)} \mathbin{\ebnfVar{Binary}} \ebnfV{\rel{Expr}(\Sigma)} \\*
    &\ebnfCont \lit{if (\ebnfV{\rel{Expr}(\Sigma)}) \ebnfV{\rel{Expr}(\Sigma)} else \ebnfV{\rel{Expr}(\Sigma)}} \\*
    &\ebnfCont \ebnfVar{Aggregate} \lit{(} \ebnfV{B^\Sigma} \lit{)} \mid
      \ebnfV{V^\Sigma} \mid \lit{\#} \ebnfV{P^\Sigma} 
      \mid \ebnfVar{Literal} \text, \\
    \ebnfVar{Unary} &\ebnfEq \lit{+} \mid \lit{-} \mid \lit{!} \text, \\
    \ebnfVar{Binary} &\ebnfEq \lit{+} \mid \lit{-} \mid \lit{*} \mid \lit{/}
    \mid \lit{==} \mid \lit{!=} \mid \lit{<} \mid \lit{<=} \mid \lit{>} \mid \lit{>=}
    \mid \lit{\&\&} \mid \lit{||} \text, \\
    \ebnfVar{Aggregate} &\ebnfEq \lit{sum} \mid \lit{prod}
    \mid \lit{all} \mid \lit{any} \text, \\
    \ebnfVar{Literal} &\ebnfEq \ebnfV{\NN} \mid \ebnfV{\RR} \mid \ebnfV{\BB} \text.
  \end{aligned}
\end{equation}

Elements of \(\rel{Expr}(\Sigma)\) are arithmetic expressions containing basic unary and binary operators, conditionals, literals \lit{int}, \lit{double} and \lit{boolean} values, as well as mentions of the symbols of \(\Sigma\). \(\rel{Expr}(\Sigma)\) contains unary, binary and aggregation operators, as well as conditional expressions; however, the exact set of available operators will not be important in the following discussion. We suppose that the set of available operators is sufficient for expressing the quantitative aspects required by the modeled problem.

Concrete and reference variables \(V^\Sigma\) may be mentioned in expressions as-is and are interpreted as references to the values they hold. In contrast, collection variables must be paired with an \emph{aggregation operator} to turn the multiple variables assigned to them into a single value. Place symbols \(P^\Sigma\) can be also mentioned and correspond to \lit{marking} dependent expressions by referring to the number of tokens on the place.

\subsubsection{Typing}

The relation \(\Sigma \vdash e \oftype \tau\) assigns a type \(\tau\) to an expression \(e \in \rel{Expr}(\Sigma)\) in the context of an \textabbr{RGSPN} signature \(\Sigma\). This typing relation is the largest ternary relation which satisfies the inference rules shown in~\cref{fig:rgspn:typing}. If an expression is assigned a type, its type is always of the form \(\delta\,\rho\).

\begin{figure}
  \begin{tabu}{@{}X[c]r@{}}
    \(\dfrac{{\diamond} \in \{\lit{+}, \lit{-}\}
      \quad \rho \in \{\lit{int}, \lit{double}\}
      \quad \Sigma \vdash e \oftype \delta\,\rho
    }{\Sigma \vdash \mathop{\diamond} e \oftype \delta\,\rho}\),
    & \Tagstyle{T-Unary\(\pm\)} \\[1ex]
    \(\dfrac{\Sigma \vdash e \oftype \delta\,\lit{boolean}
    }{\Sigma \vdash \mathop{\lit{!}} e \oftype \delta\,\lit{boolean}}\),
    & \Tagstyle{T-UnaryNot} \\[1ex]
    \(\dfrac{{\diamond} \in \{\lit{+}, \lit{-}, \lit{*}, \lit{/}\}
      \quad \rho \in \{\lit{int}, \lit{double}\}
      \quad \Sigma \vdash e_1 \oftype \delta\,\rho
      \quad \Sigma \vdash e_2 \oftype \delta\,\rho
    }{\Sigma \vdash e_1 \mathbin{\diamond} e_2 \oftype \delta \,\rho}\),
    & \Tagstyle{T-BinNumeric} \\[1ex]
    \(\dfrac{{\diamond} \in \{\lit{==}, \lit{!=}\}
      \quad \Sigma \vdash e_1 \oftype \delta\,\rho
      \quad \Sigma \vdash e_2 \oftype \delta\,\rho
    }{\Sigma \vdash e_1 \mathbin{\diamond} e_2 \oftype \delta\,\lit{boolean}}\),
    & \Tagstyle{T-BinEq} \\[1ex]
    \(\dfrac{{\diamond} \in \{\lit{<}, \lit{<=}, \lit{>}, \lit{>=}\}
      \quad \Sigma \vdash e_1 \oftype \delta\,\lit{double}
      \quad \Sigma \vdash e_2 \oftype \delta\,\lit{double}
    }{\Sigma \vdash e_1 \mathbin{\diamond} e_2 \oftype \delta\,\lit{boolean}}\),
    & \Tagstyle{T-BinCompare} \\[1ex]
    \(\dfrac{{\diamond} \in \{\lit{\&\&}, \lit{||}\}
      \quad \Sigma \vdash e_1 \oftype \delta\,\lit{boolean}
      \quad \Sigma \vdash e_2 \oftype \delta\,\lit{boolean}
    }{\Sigma \vdash e_1 \mathbin{\diamond} e_2 \oftype \delta\,\lit{boolean}}\),
    & \Tagstyle{T-BinLogical} \\[1ex]
    \(\dfrac{\Sigma \vdash e_1 \oftype \delta\,\lit{boolean}
      \quad \Sigma \vdash e_2 \oftype \delta\,\rho
      \quad \Sigma \vdash e_3 \oftype \delta\,\rho
    }{\Sigma \vdash \lit{if (\(e_1\)) \(e_2\) else \(e_3\)} \oftype \delta\,\rho}\), &
    \Tagstyle{T-If} \\[1ex]
    \(\dfrac{\rel{agg} \in \{\lit{sum}\mkern1mu, \lit{prod}\}
      \quad \rho \in \{\lit{int}, \lit{double}\}
      \quad \rel{type}(b) = \bagtype{\delta\,\rho}
    }{\Sigma \vdash \lit{\rel{agg}(\(b\))} \oftype \delta\,\rho}\),
    & \Tagstyle{T-AggNumeric} \\[1ex]
    \(\dfrac{\rel{agg} \in \{\lit{all}, \lit{any}\}
      \quad \rel{type}(b) = \bagtype{\delta\,\lit{boolean}}
    }{\Sigma \vdash \lit{\rel{agg}(\(b\))} \oftype \delta\,\lit{boolean}}\),
    & \Tagstyle{T-AggLogical} \\[1ex]
    \multicolumn{2}{@{}p{\linewidth}@{}}{
      \begin{tabu}{@{}X[c]rX[c]r@{}}
        \(v \oftype \rel{type}(v)\), & \Tagstyle{T-Var}
        & \(\lit{\#} p \oftype \lit{marking int}\), & \Tagstyle{T-Marking} \\[.5ex]
        \(\dfrac{\ell \in \rel{Literal}_\rho}{\Sigma \vdash \ell \oftype
          \lit{const}\,\rho}\), & \Tagstyle{T-Literal}
        & \(\dfrac{\Sigma \vdash e \oftype \tau\quad \tau \subtype
          \tau'}{\Sigma \vdash e \oftype \tau'}\), & \Tagstyle{T-Sub}
      \end{tabu}
    }
  \end{tabu}
  \bigskip
  where \(\rel{Literal}_{\lit{int}} = \mathbb{N}\),
  \(\rel{Literal}_{\lit{double}} = \mathbb{R}\) and
  \(\rel{Literal}_{\lit{boolean}} = \mathbb{B}\).
  \caption{Typing rules for expressions.}
  \label{fig:rgspn:typing}
\end{figure}

The types of unary operators, binary operators, conditional and aggregate expressions are captured by the rules \textsc{T-Un}, \textsc{T-Bin}, \textsc{T-If} and \textsc{T-Agg}. Instead of introducing polyporphic types for operators and typing rules for operator application, the typing rules for all operators are written out explicitly. While this approach increases the number of typing rules considerably, the lack of function types and polymorphic types allows the syntax of \(\rel{Type}\) to remain simple. If more generality is desired, operator types can be introduced to the syntax of types to support e.g.~user-defined operators. Such types are also used in modular colored Petri nets~\citep{Kindler07modular}.

In spite of being handled only in the type derivation rules, operators are polymorphic in the types of the arguments. All compound expressions are \emph{dependency polymorphic}, that is, the types of their arguments may have any dependency qualifier \(\delta\), which will be inherited by the type of the whole expression. In addition, most operators are also polymorphic in the pretypes of their arguments.

Variable and marking references are handled by \textsc{T-Var} and \textsc{T-Marking}. Referring to markings of places always produces a \lit{marking} dependent \lit{int}. In contrast, \textsc{T-Literal} assigns \lit{const} types to literal constants. Lastly, \textsc{T-Sub} allows the use of subtyping in type derivations.

\subsubsection{Analysis expressions}

The abstract syntax presented in \cref{eq:rgspn:expression} contains no expressions that produce values of dependen \lit{analysis}. In this section we propose a small set of analyses which treat \lit{marking} dependent expressions as random variables,
\begin{equation}
  \begin{aligned}
    \ebnfV{\rel{Expr}(\Sigma)} &\ebnfEq \ldots \\
    &\ebnfCont \lit{transient(\(\ebnfV{\rel{Expr}(\Sigma)}\), \(\ebnfV{\rel{Expr}(\Sigma)}\))} \mid \lit{accumulate(\(\ebnfV{\rel{Expr}(\Sigma)}\), \(\ebnfV{\rel{Expr}(\Sigma)}\))} \\
    &\ebnfCont \lit{steadystate(\(\ebnfV{\rel{Expr}(\Sigma)}\))} \mid \lit{mtff(\(\ebnfV{\rel{Expr}(\Sigma)}\))} \text.
  \end{aligned}
\end{equation}
These expressions enable embedding the analyses to be performed directly into the \textabbr{RGSPN} model.

\begin{figure}
  \begin{tabu}{@{}X[c]r@{}}
    \(\dfrac{\Sigma \vdash e_1 \oftype \lit{marking double}
      \quad \Sigma \vdash e_2 \oftype \lit{const double}
    }{\Sigma \vdash \lit{transient(\(e_1\), \(e_2\))} \oftype \lit{analysis double}}\),
    & \Tagstyle{T-Transient} \\[1ex]
    \(\dfrac{\Sigma \vdash e_1 \oftype \lit{marking double}
      \quad \Sigma \vdash e_2 \oftype \lit{const double}
    }{\Sigma \vdash \lit{accumulate(\(e_1\), \(e_2\))} \oftype \lit{analysis double}}\),
    & \Tagstyle{T-Accumulate} \\[1ex]
    \(\dfrac{\Sigma \vdash e \oftype \lit{marking double}
    }{\Sigma \vdash \lit{steadystate(\(e\))} \oftype \lit{analysis double}}\),
    & \Tagstyle{T-Steadystate} \\[1ex]
    \(\dfrac{\Sigma \vdash e \oftype \lit{marking boolean}
    }{\Sigma \vdash \lit{mtff(\(e\))} \oftype \lit{analysis double}}\),
    & \Tagstyle{T-Mtff}
  \end{tabu}
  \caption{Typing rules for analysis expressions.}
  \label{fig:rgspn:analysis-typing}
\end{figure}

The embedded analysis expressions are explicitly tagged with the \lit{analysis} dependence according to the typing rules in \cref{fig:rgspn:analysis-typing}. Thus analysis results can be forbidden from influencing the behaviour of the Petri net. For example, the steady-state expectation of a random variable cannot influence the timing of a stochastic Petri net transition, because the timing determines the steady-state of the model.

The \lit{transient} and \lit{accumulate} analyses take a random variable of type \lit{marking double} and a time instant of type \lit{const double}. The result of the analysis is the expected value of the random variable and the expected value of the time integral of the random variable at the specified time moment. This value can be determined by transient stochastic analysis of the underlying continuous-time Markov chain (\textabbr{CTMC}) of the stochastic model.

Steady-state analysis is possible by the expression \lit{steadystate}, which also takes a \lit{marking double} random variable and returns its expected value according to the steady-state distribution of the underlying \textabbr{CTMC}.

Mean-time-to-first-failure analysis, also called mean time to reach a state partition, is provided by \lit{mtff}, which takes a \lit{marking boolean} expression and returns the mean time for the expression to become \lit{true}.

\subsection{Reference \textabbr{GSPN} definitions}

In this section we consider generalized stochastic Petri nets over an \textabbr{RGSPN} signatures. These nets may contain reference symbols, such as reference places and transitions, hence the name reference \textabbr{GSPN}.

Similarly to generalized stochastic Petri nets, places are annotated with initial markings, while transitions are annotated with priorities and weights. To describe the quantitative aspects of the model, variable symbols are annotated with algebraic expressions over the net's signature.

\begin{dfn}
  \label{dfn:rgspn:rgspn}
  A \emph{reference \textabbr{gspn}} is a tuple \(\rel{RGSPN} = \ltup \Sigma, F, W, M_0, \pi, \lambda, \rel{value} \rtup\), where:
  \begin{compactitem}
  \item \(\Sigma\) is a reference \textabbr{GSPN} signature.
  \item \(F \subseteq P \times \{\inarc, \outarc, \inharc\} \times T\) is the set of \emph{arcs}.
  \item \(W\colon F \to \rel{Expr}(\Sigma)\) is the \emph{arc inscription function}.
  \item \(M_0\colon P_c \to \rel{Expr}(\Sigma)\) is the \emph{initial marking function}.
  \item \(\pi\colon T_c \to \rel{Expr}(\Sigma) \cup \{\bot\}\) is the \emph{transition priority function}.
  \item \(\lambda\colon T_c \to \rel{Expr}(\Sigma)\) is the \emph{transition weight function}. If \(\pi(t) = \bot\), we will refer to \(\lambda(t)\) as the \emph{transition rate} of the \emph{timed} transition \(t\). Otherwise \(t\) will be called \emph{immediate}.
  \item \(\rel{value}\colon V_c \to \rel{Expr}(\Sigma)\) is the \emph{variable value function}.
  \end{compactitem}
\end{dfn}

\Cref{dfn:rgspn:rgspn} replaces numerical values in generalized stochastic Petri nets with expressions over the \textabbr{RGSPN}'s signature. Therefore, quantitative aspects can be described by expressions. The behaviour of reference symbols is left unspecified, because they can only stand for other symbols through reference assignment.

Generalized stochastic Petri nets are usually defined such that transitions with priority 0 are timed, while transitions with positive priority have immediate firing policy. However, in \textabbr{RGSPN}s, the transition priority is an expression possibly involving various symbols from the signature \(\Sigma\). As we consider \textabbr{RGSPN}s independently from a reference assignment relation \(\assign\), these expressions may not be readily evaluated. Hence the special value \(\bot\) was introduces to signify timed transitions without the evaluation of expressions.

Quantitative aspects of an \textabbr{RGSPN} model should satify the following typing conditions:

\begin{dfn}
  An \textabbr{RGSPN} \(\rel{RGSPN} = \ltup \Sigma, F, W, M_0, \pi, \lambda, \rel{value} \rtup\) is \emph{well-typed} if
  \begin{compactitem}
  \item \(\Sigma \vdash W(f) \oftype \lit{marking int}\) for all \(f \in F\),
  \item \(\Sigma \vdash M_0(p) \oftype \lit{const int}\) for all \(p \in P_c\),
  \item \(\Sigma \vdash \pi(t) \oftype \lit{const int}\) if \(\pi(t) \ne \bot\) for all \(t \in T_c\),
  \item \(\Sigma \vdash \lambda(t) \oftype \lit{marking double}\) for all \(t \in T_c\),
  \item \(\Sigma \vdash \rel{value}(v) \oftype \rel{type}(v)\) for all \(v \in V_c\).
  \end{compactitem}
\end{dfn}

Expressions with \lit{analysis} dependence are forbidden from influencing the behavior of the \textabbr{RGSPN}, as changes in net behavior affect the outcomes of analyses and would lead to a feedback loop. In contrast, \lit{marking} dependent arc weights and transition weights are allowed, since they can be handled by usual stochastic analysis techniques.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
