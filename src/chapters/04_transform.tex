\chapter{Incremental view synchronization}
\label{chap:transform}

Complex industrial toolchains used for the model-based design of safety-critical cyber-physical systems frequently depend on various models on different levels of abstraction where abstract models are derived by model transformations. The derived models are often \emph{views}, which aim to focus attention from a given \emph{viewpoint} such that details relevant to a specific group of stakeholders are retained~\citep{Bruneliere17survey}. The views contain information that is related to and coming from other models, which can also be themselves other views. Incremental small-step execution of model transformations aids in reducing the computations costs of view maintenance~\citep{Varro15styles}.

In this chapter we propose a means to assemble formal stochastic models from domain models by model transformation. The resulting analysis model is a \emph{view} of the engineering model from a \emph{reliability} or \emph{performability} viewpoint. The transformation should be \circled{1}~\emph{parametric} in the sense that the source metamodel, the transformation rules and the analysis model fragments that are instantiated may be specified by the user. In addition, stochastic Petri nets produced by the transformation should be \circled{2}~\emph{compatible with external analysis tools.} As a key to interpret analysis results of the derived stochastic models automatically, the transformation should ensure \circled{3}~\emph{end-to-end traceability} between source model elements and the quantitative aspects of the stochastic model. Lastly, to support efficient mapping of constantly changing design candidates in design-space exploration, the transformation should be \circled{4}~\emph{executed incrementally} driven by change notifications of the source model.

Existing transformation languages, such as \textabbr{ATL}~\citep{Jouault08atl}, \mixedabbr{QVT}r~\citep[Chapter~7]{OMG16qvt} or \textabbr{VIATRA} Views~\citep{Debreceni14viewmodel} can describe mappings between instances of arbitrary metamodels; therefore they satisfy the requirement of \circled{1}~user configurability. These language require the specification of the results of the transformation at the low level of individual model objects and links. While creating single objects at once is satisfactory for views that aim to create \emph{abstractions} of the source model, automatic derivation of stochastic models is closer to \emph{compilation}. The result of mapping even just one source element may have a complicated result, such as a collection of Petri net places, transitions and expressions trees describing quantitative aspects of the model. Hence we propose a transformation specification language tightly integrated with \textAbbr{RGSPN}s introduced in \cref{chap:rgspn} as an alternative to general-purpose transformation languages for stochastic model creation.

The left side of the transformation rules are graph patterns which select the parts of the source model to be mapped. On the right side, the transformation results are specified as \emph{\textabbr{RGSPN} modules}, which are \textAbbr{RGSPN} model fragments. The typing discipline from \vref{dfn:rgspn:well-typed} is extended to transformation rules to aid in catching bugs.

In current analysis tools, there is little support for reference symbols, variables and collections introduced in \textAbbr{RGSPN}s. To \circled{2}~ensure compatbility, a \emph{inlining} step is also incorporated into the transformation chain. The inlining \emph{concretizes} the \emph{abstract} \textabbr{RGSPN} constructed according to the user-provided view specification and yields a \emph{concrete} \textabbr{RGSPN}, that contains no references, collections or references to variables. Variable symbols are kept so that they can exported to the analysis tool as stochastic metrics to be computed or as queries to be answered. Matching of the queries to source model concepts is provided by \circled{3}~traceability relations that are maintained implicitly, i.e.~without additional user intervention.

The \circled{4}~incremental execution of the transformation is ensured by the use of an incremental graph query engine~\citep{Ujhelyi15incquery} and a reactive model transformation platform~\citep{Bergmann15viatra}. If a step in the transformation chain cannot be executed due to a malformed input model the effects of the transformation are \emph{delayed} until the issue is resolved. Upon delaying, an error marker is generated that is removed when the transformation can resume successfully.

After briefly reviewing related work we describe the proposed transformation chains, as well as its specification language and semantics. Then the instantiation of \textabbr{RGSPN} modules is discussed, finally followed by the details of the concretization transformation and its handling of inconsistencies by the means of delayed execution.

\section{Related work: view synchronization for formal models}
\label{chap:transform:relwork}


\subsection{Incremental transformation languages}

\todo*{}

\subsection{Transformation languages for stochastic models}

\todo*{}

\section{Overview of the transformation engine}
\label{chap:transfrom:specify}

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/transformation_chain}
  \caption{Overview of the transformation chain.}
  \label{fig:transform:overview}
\end{figure}

The transformation chain from engineering models to analyzable \textAbbr{RGSPN}s is shown in \vref{fig:transform:overview}. The architecture is divided into three parts: \begin{inparaenum}
\item the \emph{parameters} of the transformation, which constitute the transformation specification provided by the user,
\item the \emph{models} and model transformations participating in the chain and
\item the \emph{trace} models providing end-to-end traceability.
\end{inparaenum}

\subsection{Transformation specification}

The transformation description contains the \emph{precondition queries}, which are executed on an incremental model query engine. For each query match the \emph{transformation rules} specify which \emph{\textabbr{RGSPN}} module should be instantiated.

In addition, the user is able to reuse quantitative aspects of the engineering model in the analysis model and define new quantitative aspects to be evaluated as stochastic queries. These \emph{associated symbols}, along with their traceability information play roles similar to the parameters (prefixed with \enquote{\$}), stochastic metrics (\enquote{/}) and queries (\enquote{/\$}) introduced as an extension to \textabbr{UML} diagrams by \citet{Bernardi03building}.

Transformation rules can govern the mapping of numeric attributes from the domain model to the variable symbols of the \textabbr{RGSPN}. Attributes may be marked as parameters, which are retained as parameters symbols in \textabbr{RGSPN} and when the analysis model is exported to external solvers. Therefore the parameter mapping relates domain attributes to sensitivity analysis~\citep{Blake88sensitivity}, parametric solution of Markov chains~\citep{Hahn11parametric} and parameter synthesis \citep{Quatmann16mdp,Molnar17optimization}, letting users perform the aforementioned tasks directly on the domain model.

Moreover, \emph{derived} features may also be specified that associate \textabbr{RGSPN} symbols with domain model elements. In contrast with model query based approaches for the creation of derived features~\citep{Rath12derived} the domain model is not modified to incorporate the features. However, code generation and the \emph{extension methods} feature of \emph{Xtend}\footnoteurl{https://www.eclipse.org/xtend/} are utilized in \vref{sec:apply:environment} to emulate derived features syntactically in a general purpose programming language.

\subsection{Transformation chain}

As it is shown in \vref{fig:transform:overview} the construction of \textabbr{RGSPN} analysis models is realized as a \emph{chain} of two model transformations.

The precondition queries of transformation rules are ran on the 1.~\emph{source model} by an \emph{incremental query engine}. The 2.~\emph{view transformation} maintains a 3.~\emph{abstract analysis model} based on the query matches of the precondition queries and instantiates the \textabbr{RGSPN} modules according to the transformation rules. In addition, the associated symbols relating to the quantitative aspects of the source model elements are instantiated. A \emph{view trace model} links the elements and query matches of the source model to the symbols of the abstract \textabbr{RGSPN}.

The abstract \textabbr{RGSPN} contains reference symbols, variables and collections that are not directly exportable to analysis tools. Therefore the 4.~\emph{concretizer transformation} is needed to \emph{inline} these features and obtain a 5.~\emph{concrete analysis model}, which is an \textabbr{RGSPN} without advanced features. The concrete model can be exported as a \textabbr{GSPN} possibly parameter- and marking-dependent transition rates for analysis with external tools. Furthermore, the value expressions of the retained variable symbols, which refer to elements of the concrete model, can serve as stochastic metrics and queries to be analyzed.

If the abstract analysis model is inconsistent, e.g.~it contains unassigned references or circular references, concretization is delayed and \emph{error} markers are generated until the inconsistency is resolved. The \emph{concretizer trace model} links the abstract analysis model to the concrete one; moreover, it also allows the interpretation of error markers.

Both the concrete and abstract \textAbbr{RGSPN}s are fully materialized as instance models so that they can be freely inspected and exported. It is also possible to subscribe to change notification of either of the models, for example, to incorporate our transformation chain into a larger chain.

\subsection{End-to-end traceability}

Fully traversing the view and concretizer trace models allows the association of concrete \textabbr{RGSPN} symbols with source model elements. Thus when an external solver is interfaced with the transformation, it is sufficient to provide traceability between the concrete analysis model and the external solver so that the analysis results remain interpretable in the context of the source domain model.

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/derived_feature_traceability}
  \caption{Traceability for associated symbols.}
  \label{fig:transform:derived}
\end{figure}

\begin{runningExample}
  \Vref{fig:transform:derived} shows the trace links for an \textabbr{RGSPN} symbol derived feature \lit{total\-Thinking\-Time} of the domain class \lit{Table}.

  The first trace link is the view trace model associates the domain object \lit{T} with the reference symbol \lit{T.total\-Thinking\-Time} in the abstract analysis model. A variable symbol is assigned to the reference.

  The concretization transformation resolves and inlines all references, therefore both trace links from the reference symbol and the concrete symbol in the concretization trace model point at the same variable symbol in the concrete analysis model. As result of the inlining, the aggregation operator in value expression of the variable is replaced with the sum of the member variables. In the example, these members are token count expressions \lit{\#thinking1} and \lit{\#thinking2}.

  If the concrete analysis model is exported to an external analysis tool, such as PetriDotNet~\citep{Voros17pdn}, the \textabbr{PNML} serializer may also output traceability information. In the example, the value expression of \lit{T.total\-Thinking\-Time} is turned into a reward configuration for PetriDotNet. The end-to-end trace links associate the exported reward configuration with the derived feature, hence the results of stochastic analysis can be interpreted in the context of the domain model and its derived features.
\end{runningExample}

\section{Transformation specification language}

We present the transformation specification language trough a running example. \Cref{tbl:transform:feature,tbl:transform:mapping} show an example transformation description for the dining philosophers domain. On the left graph patterns are displayed as subgraphs, while the \textabbr{RGSPN} modules on the right also use graphical concrete syntax. In the middle column, the textual concrete syntax of transformation descriptions is shown.

\subsection{Feature rules}

\begin{table}%
  \caption{Feature rules for dining philosophers transformation specification.}%
  \label{tbl:transform:feature}
  \lstset{
    basicstyle={\ttfamily\small},
    columns=fixed,numbers=none,
    aboveskip=0pt,belowskip=-1.2\baselineskip,
    language=ecore2pn
  }%
  \centering
  \begin{tabular}{@{}>{\centering\arraybackslash}m{0.20\textwidth}@{}m{0.42\textwidth}@{}>{\centering\arraybackslash}m{0.38\textwidth}@{}}
    \toprule
    \multicolumn{1}{@{}c}{Domain class} & \multicolumn{1}{c}{Transformation rule} &
    \multicolumn{1}{c@{}}{Associated symbols} \\
    \midrule
    & \begin{lstlisting}
features {
\end{lstlisting} & \\
    \includegraphics[scale=0.8]{figures/phil_class}& \begin{lstlisting}
  Philosopher {
    param eatingRate
  }
\end{lstlisting} &\includegraphics[scale=0.8]{figures/phil_features}\\
  \includegraphics[scale=0.8]{figures/table_class}& \begin{lstlisting}
  Table {
    derived prop double
        ^totalThinkingTime^
  }
\end{lstlisting} &\includegraphics[scale=0.8]{figures/table_features}\\
  & \begin{lstlisting}
}
\end{lstlisting} &\\
    \bottomrule
  \end{tabular}
\end{table}    

The first section of the transformation specification contains \emph{feature rules} that describe the associated symbols relating to the \emph{features} (\emph{attributes}) of the domain model elements. The feature rule section is introduced by the \lit{features} keyword. Each domain class may have a sub-section describing the mapping of its features.

By default, each \lit{int}, \lit{double} and \lit{boolean} attribute of a domain class is mapped to a \lit{const} variable symbol in the abstract \textabbr{RGSPN}. The value expression of the variable symbol is a literal that equals to the value of the domain attribute.

Users may override the attribute mapping of \lit{double} features by specifying \lit{param} mapping instead. Attributes marked as \lit{param} are turned into parameter symbols instead.

Lastly, feature rules may specify \texttt{derived} features. An \textabbr{RGSPN} reference symbol with the given type and name is created and is associated with the domain element.

\begin{runningExample}
  The metamodel for the dining philosophers domain contains the classes \lit{Philosopher} and \lit{Table}. The two attributes of type \lit{double} of \lit{Philosopher} are \lit{eating\-Rate} and \lit{hungry\-Rate}, while \lit{Table} has no attributes.

  For \lit{Philosopher} the feature rule in \vref{tbl:transform:feature} marks the attribute \lit{eating\-Rate} as a parameter. Hence \lit{eating\-Rate} is mapped to the \textabbr{RGSPN} as a parameter symbol, while \lit{const} variable symbol is created for \lit{hungry\-Rate}.

  The \lit{Table} feature rule prescribes a derived feature \lit{total\-Thinking\-Time} of type \(\vartype{\lit{prop}}{\lit{double}}\). Hence a reference symbol with the same name and type is associated with \lit{Table} objects.
\end{runningExample}

\subsection{Mapping rules}

\begin{table}%
  \caption{Mapping rules for dining philosophers transformation specification.}%
  \label{tbl:transform:mapping}
  \lstset{
    basicstyle={\ttfamily\small},
    columns=fixed,numbers=none,
    aboveskip=0pt,belowskip=-1.2\baselineskip,
    language=ecore2pn
  }%
  \centering
  \begin{tabular}{@{}>{\centering\arraybackslash}m{0.20\textwidth}@{}m{0.42\textwidth}@{}>{\centering\arraybackslash}m{0.38\textwidth}@{}}
    \toprule
    \multicolumn{1}{@{}c}{Precondition} & \multicolumn{1}{c}{Transformation rule} &
    \multicolumn{1}{c@{}}{\textabbr{RGSPN} module} \\
    \midrule
    \includegraphics[scale=0.8]{figures/q_table_pattern}& \begin{lstlisting}
mapping qTable(T)
    => TableMod TM {
  T.^totalThinkingTime^
      := TM.totalThinkingTime
}
\end{lstlisting} &\includegraphics[scale=0.8]{figures/table_module}\\[-0.2ex]
  \includegraphics[scale=0.8]{figures/q_phil_pattern}& \begin{lstlisting}
mapping qPhil(T, P)
    => PhilMod PM {
  lookup qTable(T) => TM
  PM.^hungryRate^ := P.hungryRate
  PM.^eatingRate^ := P.eatingRate
  TM.^thinkingTimes^
      += PM.thinkingTime
}
\end{lstlisting} &\includegraphics[scale=0.8]{figures/phil_module}\\[-2ex]
  \includegraphics[scale=0.8]{figures/q_adjacent_pattern}& \begin{lstlisting}
mapping qAdjacent(T, L, R) {
  lookup qPhil(T, L) => PM1
  lookup qPhil(T, R) => PM2
  PM2.^leftFork^ := PM1.rightFork
}
\end{lstlisting} &\includegraphics[scale=0.8]{figures/adjacent_phils_module}\\
    \bottomrule
  \end{tabular}
\end{table}

A \emph{mapping} rule associates a \emph{precondition} model query with a set of \emph{lookup declarations}, assignments and collections membership declarations, as well as optionally a \emph{postcondition} \textabbr{RGSPN} module. Thus the abstract analysis modules is weaved from \textabbr{RGSPN} module instances and the edges added between them by the mappings.

For every tuple of match arguments in the match set of the precondition query instances of the assignments, collections memberships and the \textabbr{RGSPN} module are added to the abstract analysis model. The instantiation of modules is perfomed by copying their contents to the abstract analysis model after renaming their symbols to avoid collisions. The match argument tuple serves as the source of traceability links to the instantiated objects.

After the keyword \lit{mapping} the precondition graph pattern is named, followed by its list of parameters. The associated symbols of match arguments are accessible in the body of the mapping rule by mentioning the name of the match argument, followed by the dot operator and the name of the associated symbol.

The name of the \textabbr{RGSPN} module to instantiate and a \emph{local name} for the module instance may be specified after the \lit{=>} operator. If the module instantiation clause is present symbols inside the module instance can be referred to using the local name of the instance and the dot operator similarly to associated symbol references.

\subsubsection{Lookup declarations}

The view trace model can be traversed during the view transformation by \emph{lookup declarations}, analogously to the \texttt{@Lookup} annotation introduced by \citet{Debreceni14viewmodel} for the traversal of traceability relations in view maintenance. Introduced by the keywords \lit{lookup} they name a precondition pattern and provide a list of match arguments. The match arguments must be a subset of the parameters of the containing mapping rule and a pattern match of the specified pattern must exist.

After the operator \lit{=>} a local name may be given to the module instance created by the lookup up mapping rule. Hence it is possible to refer to symbols instantiated by other mapping rules in order to connect them with the rest of the analysis model. The execution of the view transformation, which is described in \vref{chap:transform:view}, ensures that the modules can be instantiated in any order and allows cyclic lookups between mapping rules.

\subsubsection{Edge declarations}

Edges between different \textabbr{RGSPN} module instances and symbols associated with domain objects are also supported. The \lit{:=} and \lit{+=} operators may add reference assignments and collection membership edges, respectively. Typing rules in \vref{dfn:rgspn:well-typed} are checked in mapping rules as well as in \textabbr{RGSPN} modules. Thus the abstract \textabbr{RGSPN} output by the view transformation is ensured to be well-typed.

\begin{runningExample}
  In \vref{tbl:transform:mapping} three mapping rules are given for the dining philosophers domain. The feature rules in \vref{tbl:transform:feature} are assumed for the mappings.

  The pattern \lit{qTable} matches for all instances \lit{T} of the class \lit{Table}. An instance of the module \lit{TableMod} is created with the local name \lit{TM}. The symbol \lit{total\-Thinking\-Time} of \lit{TM} is assigned to the derived symbol with the same name of the domain object \lit{T}.

  The pattern \lit{qPhil} matches each philosopher \lit{P} sitting around a table \lit{T}. The corresponding mapping instantiates \lit{PhilMod} with the local name \lit{PM}. The table \lit{T} is included in the match parameter list such that the module \lit{TM} created by the mapping \lit{qTable} for \lit{T} can be looked up. The references \lit{hungry\-Rate} and \lit{eating\-Rate} inside \lit{PM} are assigned to the symbols constructed from the attributes of \lit{P}. The variable symbol \lit{thinking\-Time} of \lit{PM} is added to the collection \lit{thinking\-Times} of \lit{PM}.

  The interaction between the instances of \lit{TableMod} and \lit{PhilMod} showcases the advantages of collection symbols in \textAbbr{RGSPN}. The individual performance measures \lit{thinking\-Time} of philosophers are added to a collection, such that the aggregate performance measure \lit{total\-Thinking\-Time} can be computed.

  Lastly, \lit{qAdjacent} find philosophers \lit{L} and \lit{R} sitting next to each other around the table \lit{T}. While the corresponding mapping has no \textabbr{RGSPN} module to instantiate, it looks up the modules instances \lit{PM1} and \lit{PM2}, respectively. The reference to the left fork of the right philosopher is assigned to the right for of the left philosopher, which completes the dining philosophers model.
\end{runningExample}

\section{Generic view transformation to stochastic Petri nets}
\label{chap:transform:view}

The first transformation in our transformation chain is the view transformation that derives abstract \textabbr{RGSPN} analysis models from engineering model. Its four main objectives are
\begin{itemize*}
\item the instantiation of associated symbols for domain objects,
\item the instantiation of \textabbr{RGSPN} modules for mapping rule precondition matches,
\item the instantiation of additional assignment and collection membership edges according to lookup specifications and
\item the synchronization of the value expressions of associated attribute symbols with the values of domain attributes.
\end{itemize*}

The creation and removel of associated symbols, as well as \textabbr{RGSPN} modules and edges follows the strategy for incremental view maintenance by graph queries proposed by \citet{Debreceni14viewmodel}. Analysis model elements are created for precondition pattern matches with missing traceability links, while analysis model elements with dangling traceability links are deleted. Hence the style of instantiation is small-step \emph{incrementality by traceability}~\citep{Varro15styles}. The trace model is \emph{implicit}, i.e.~users do not need to define a metamodel for traceability links themselves. The transformation engine maintains the view trace model automatically instead.

Edges defined inside mapping rules are only instantiated when there is a traceability link for the abstract \textabbr{RGSPN} symbols on both ends of the edge and the precondition of the mapping rule matches. To this end a \emph{connection} graph pattern is generated which incorporates the precondition pattern and  also matches the traceability links for the looked up \textabbr{RGSPN} modules and associated symbols of the mapping rule. By evaluating the generated pattern over the source model and the view trace model jointly the set of edges that can be added to the abstract analysis model are determined. Dedicated traceability links are also added between the matches of the generated patterns and the inserted edges; therefore the edges can be removed when their corresponding match of the connection pattern disappears and the traceability link becomes dangling.

\begin{runningExample}
  The connection pattern generated from the mapping rule \lit{qTable} in \vref{tbl:transform:mapping} is \(\lit{qTable}^*(x) = \lit{qTable}(x) \land (\exists \ell_1 .\)\rel{mod\-ule\-In\-stance\-Trace}\((\lit{qTable}, \ltup x \rtup, \ell_1)) \land (\exists \ell_2 .\)\rel{as\-so\-ci\-a\-ted\-Sym\-bol\-Trace}\((x, \ell_2))\), where \rel{mod\-ule\-In\-stance\-Trace}\((\phi, t, \ell)\) indicates that \(\ell\) is the traceability link for the \textabbr{RGSPN} module instance created by the mapping rule with precondition \(\phi\) for the pattern match tuple \(t\) and \rel{as\-so\-ci\-a\-ted\-Sym\-bol\-Trace}\((x, \ell)\) indicates that \(\ell\) is the traceability link for the symbols associated with the source object \(x\). Likewise we have \(\lit{qPhil}^*(x, y) = \lit{qPhil}(x, y) \land (\exists \ell_1 .\)\rel{mod\-ule\-In\-stance\-Trace}\((\lit{qPhil}, \ltup x, y \rtup, \ell_1)) \land (\exists \ell_2 .\)\rel{as\-so\-ci\-a\-ted\-Sym\-bol\-Trace}\((y, \ell_2)) \land (\exists \ell_3 .\)\rel{mod\-ule\-In\-stance\-Trace}\((\lit{qTable}, \ltup x \rtup, \ell_3))\) and \(\lit{qAdjacent}^*(x, y, z) = \lit{qAdjacent}(x, y, z) \land (\exists \ell_1 .\)\rel{mod\-ule\-In\-stance\-Trace}\((\lit{qPhil}, \ltup x, y \rtup, \ell_1)) \land (\exists \ell_2 .\)\rel{mod\-ule\-In\-stance\-Trace}\((\lit{qPhil}, \ltup x, z \rtup, \ell_2))\).
\end{runningExample}

Symbols associated with numerical attributes of domain objects are synchronized with the values of the attributes. The transformation engine subscribes to change notifications from the source model and updates values of the symbols associated with the changed object. Hence the attribute synchronization is \emph{reactive source incremental}.

\begin{runningExample}
  \Cref{fig:transform:view-1,fig:transform:view-2,fig:transform:view-3} show an example transformation of a dining philosophers domain model according to the feature rules in \vref{tbl:transform:feature} and the mapping rules in \vref{tbl:transform:mapping}. Symbols inside module instances with no adjacent edges between modules were suppressed for clarity. Trace links are indicated by writing the names of the linked pattern matches in the analysis model, as well as the coloring of pattern matches and model elements.

  The initial model in \vref{fig:transform:view-1} contains a \lit{Table} \lit{T} and a \lit{Philosopher} \lit{P1}. The precondition query \lit{qTable} has a single match \(\ltup \lit{T} \rtup\) and \lit{qPhil} has a single match \(\ltup \lit{T}, \lit{P1} \rtup\).

  The associated symbols \lit{P1.eatingRate} and \lit{P1.hungryRate} were created for \lit{P1}. The derived feature symbol \lit{T.totalThinkingTime} is associated with \lit{T}. Module instances \lit{TM} of \lit{TableMod} and \lit{PM1} of \lit{PhilMod} were also added to the abstract analysis model for the precondition matches \(\lit{qTable}\ltup \lit{T} \rtup\) and \(\lit{qPhil}\ltup \lit{T}, \lit{P1} \rtup\), respectively. The connection patterns \(\lit{qTable}^*\) generated from the \lit{qTable} mapping rule and \(\lit{qPhil}^*\) generated from the \lit{qPhil} mapping rule govern the insertion of \textabbr{RGSPN} edges between modules. The connection match \(\lit{qTable}^*\ltup \lit{T} \rtup\) assigns the variable \lit{TM.totalThinkingTime} to the derived reference \lit{T.totalThinkingTime}. In addition, \(\lit{qPhil}^*\ltup \lit{T}, \lit{P1} \rtup\) adds \lit{PM1.thinkingTime} to the collection \lit{TM.thinkingTimes} and assigns the features symbols associated with \lit{T} to the respective reference symbols in the module \lit{PM1} such that they can be mentioned in the expressions inside the implementation of \lit{PhilMod}.

  In \vref{fig:transform:view-2} the attribute \lit{hungryRate} of \lit{P1} was changed. Therefore the transformation synchronized the literal in the value expression of the feature symbol \lit{P1.hungryRate} in the abstract analysis model.

  In \vref{fig:transform:view-3} a new \lit{Philosopher} \lit{P2} was created, which sits both on the left and right of \lit{P1} around the circular table \lit{T}. New precondition matches \(\lit{qPhil}\ltup \lit{T}, \lit{P} \rtup\), \(\lit{qAdjacent}\ltup \lit{T}, \lit{P1}, \lit{P2} \rtup\) and \(\lit{qAdjacent}\ltup \lit{T}, \lit{P2}, \lit{P1} \rtup\) appeared, which lead to the instantiation of a new \lit{PhilMod} \lit{PM2}. The symbols inside the \lit{PM2} are connected to the rest of the analysis model with edges due to the connection match \(\lit{qPhil}^*\ltup \lit{T}, \lit{P} \rtup\). Furthermore, matches \(\lit{qAdjacent}^*\ltup \lit{T}, \lit{P1}, \lit{P2} \rtup\) and \(\lit{qAdjacent}^*\ltup \lit{T}, \lit{P2}, \lit{P1} \rtup\) of the connection query generated from the mapping rule \lit{qAdjacent} caused the assignments of \lit{PM1.leftFork} to \lit{PM2.rightFork} and \lit{PM2.leftFork} to \lit{PM2.rightFork}.

  Because analysis model elements with dangling trace links are removed the deletion of \lit{P2} from the source model would cause the view transformation to restore the analysis model to the state shown in \cref{fig:transform:view-2}.
\end{runningExample}

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/view_transformation_example_initial} 
  \caption{Initial setup for the example view transformation.}
  \label{fig:transform:view-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/view_transformation_example_2}
  \caption{State of the example view transformation after modifying \lit{P1.eatingRate}.}
  \label{fig:transform:view-2}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{figures/view_transformation_example}
  \caption{State of the example view transformation after adding a new philosopher \lit{P2}.}
  \label{fig:transform:view-3}
\end{figure}

\section{Stochastic Petri net concretization}
\label{chap:transform:concretizer}